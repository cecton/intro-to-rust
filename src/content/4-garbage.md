# Sans garbage collector

La mémoire a permis, pendant des années, certaines failles car une mémoire pleine entraîne une erreur pouvant être exploitée par des hackers. Pour éviter cela, un ["garbage collector"](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)) ("ramasse-miette" en Français) permet de supprimer les objets non utilisé en mémoire. C'est une sorte de gestionnaire de mémoire automatique, il va vérifier la mémoire pour libérer l'espace occupé par des données qui ne sont plus utilisé par le programme. Le garbage collector est implémenté différemment dans chaque langage, la plupart des langage de programmation haut niveau ont cette spécificité "out of the box" tandis que la plupart des langages bas-niveau le font grâce à des bibliothèque de code.

Rust est un des langages de programmation bas-niveau qui n'utilise pas de garbage-collector car il vérifie dès la compilation si une erreur est susceptible de survenir dans la mémoire. Une fonctionnalité assez unique de Rust, l'Ownership, permet un lien entre une variable et sa valeur. une fois la valeur transmise, la variable n'est plus adressable.

Rust vous donne le choix de stocker des données sur ["the stack"](https://en.wikipedia.org/wiki/Stack-based_memory_allocation) ou ["the heap"](https://en.wikipedia.org/wiki/Memory_management#DYNAMIC), ce sont tous les deux des emplacements de la mémoire mais qui sont organisés différemment. La pile enregistre les valeurs dans l'ordre de réception et enlève les valeurs dans l'autre sens selon le principe de dernier entré premier sorti, toutes les données doivent avoir une taille fixe et connue au moment de la compilation. Lorsque vous ajoutez des données sur le tas, les données ont parfois une taille qui peut changer, vous demandez en fait une certaine quantité de mémoire, le gestionnaire de mémoire va trouver un emplacement sur le tas qui est suffisamment grand, va le marquer comme étant en cours d'utilisation et retournera un pointeur avec l'adresse de cet emplacement.

Le compilateur détermine au moment de la compilation quand la mémoire n'est plus nécessaire et peut être nettoyé. Cela permet une utilisation efficace de la mémoire ainsi qu'un accès à la mémoire plus performant en plus du fait de ne pas avoir un garbage collector qui fonctionne en permanence. Et grâce au concept d'ownership les programmeurs Rust peuvent écrire des programmes sans devoir allouer manuellement la mémoire (comme on doit le faire en C/C++). Vous pourrez en apprendre plus en pratique sur ce concept dans le [projet](16-3-ownership.md) à la fin de ce livre

[Tilde](https://www.tilde.io/), un des premiers utilisateurs de Rust en production dans leur produit [Skylight](https://www.skylight.io/), a découvert qu'il étaient en mesure de [réduire leur utilisation de la mémoire de 5GiB à 50Mib](https://www.rust-lang.org/static/pdfs/Rust-Tilde-Whitepaper.pdf) en réécrivant certains points de terminaison HTTP Java dans un Rust idiomatique. Des économies comme celle-ci s'additionnent rapidement lorsque les fournisseurs de cloud facturent des prix plus élevés pour une mémoire accrue ou des noeuds supplémentaires.

Les projets Rust sont bien adaptés, grâce à cette spécificité pour être utilisés comme bibliothèques par d'autres langages de programmation via des interfaces de fonctions étrangères. Cela permet aux projets existants de remplacer les éléments essentiels aux performances par du code Rust rapide sans les risques de sécurité de la mémoire inhérents aux autres langages de programmation de systèmes. Certains projets ont même été [réécrits progressivement en Rust](https://people.gnome.org/~federico/blog/librsvg-is-almost-rustified.html) en utilisant ces techniques.
